#!/usr/bin/env ruby
# frozen_string_literal: true

require 'search_solr_tools'
require 'thor'

class SolrHarvestCLI < Thor
  map %w[--version -v] => :__print_version

  ERRCODE_SOLR_PING = 1
  ERRCODE_SOURCE_PING = 2
  ERRCODE_SOURCE_NO_RESULTS = 4
  ERRCODE_SOURCE_HARVEST_ERROR = 8
  ERRCODE_DOCUMENT_INVALID = 16
  ERRCODE_INGEST_ERROR = 32
  ERRCODE_UNKNOWN = 128

  ERRCODE_DESC = {
      ERRCODE_SOLR_PING => 'Solr instance did not return a successful ping',
      ERRCODE_SOURCE_PING => 'Source to be harvested did not return a successful ping',
      ERRCODE_SOURCE_NO_RESULTS => 'Source to be harvested returned no documents matching query',
      ERRCODE_SOURCE_HARVEST_ERROR => 'One or more source documents returned an error when trying to retrieve or translate',
      ERRCODE_DOCUMENT_INVALID => 'One or more documents to be harvested was invalid (malformed)',
      ERRCODE_INGEST_ERROR => 'Solr returned an error trying to ingest one or more harvested documents',
      ERRCODE_UNKNOWN => 'Generic, unspecified placeholder error code'
  }

  desc '--version, -v', 'print the version'
  def __print_version
    puts SearchSolrTools::VERSION
  end

  desc 'errcode', 'Get a description of the specified error code'
  def errcode(code)
    code = code.to_i
    code_list = []

    # Loop through all bit-flag values
    [128, 64, 32, 16, 8, 4, 2, 1].each do |k|
      if code >= k
        code_list.prepend k
        code -= k
      end
    end

    puts "CODE | DESCRIPTION"
    puts "-----+------------"
    code_list.each do |k|
      text = ERRCODE_DESC.keys.include?(k) ? ERRCODE_DESC[k] : "INVALID CODE NUMBER"
      puts "%4d | %s" % [k, text]
    end
  end

  desc 'ping', 'Ping the solr and harvesting endpoints related to the specified data center(s)'
  option :data_center, type: :array, required: true
  option :environment, required: true
  def ping()
    solr_success = true
    source_success = true
    options[:data_center].each do |target|
      begin
        harvest_class = get_harvester_class(target)
        harvester = harvest_class.new(options[:environment])
        solr_status = harvester.ping_solr
        source_status = harvester.ping_source
      rescue StandardError => e
        solr_status = false
        source_status = false
        puts "Error trying to ping for #{target}: #{e}"
      end
      solr_success &&= solr_status
      source_success &&= source_status
      puts "Target: #{target}, Solr ping OK? #{solr_status}, data center ping OK? #{source_status}"
    end

    # Error code is 0 if all pings were successful.  Otherwise, add the ping
    # error codes.  The "combined" error code was intentionally set to the sum
    # of the individual pings for easier combination
    errcode = 0
    errcode += ERRCODE_SOLR_PING unless solr_success
    errcode += ERRCODE_SOURCE_PING unless source_success
    exit errcode if errcode != 0
  end

  desc 'harvest', 'Harvest from the specified data centers'
  option :data_center, type: :array, required: true
  option :environment, required: true
  option :die_on_failure, type: :boolean
  def harvest(die_on_failure = options[:die_on_failure] || false)
    options[:data_center].each do |target|
      puts "Target: #{target}"
      begin
        harvest_class = get_harvester_class(target)
        harvester = harvest_class.new(options[:environment], die_on_failure)
        code = 0
        unless harvester.ping_solr
          puts "Solr service for #{target} did not return a successful ping.  Is the instance up?"
          code += ERRCODE_SOLR_PING
        end
        unless harvester.ping_source
          puts "Data source for #{target} did not return a successful ping.  Is the source available?"
          code += ERRCODE_SOURCE_PING
        end
        exit code if code != 0

        harvester.harvest_and_delete
      rescue SearchSolrTools::Errors::HarvestError => e
        puts "THERE WERE HARVEST STATUS ERRORS"
        exit ERRCODE_UNKNOWN
      rescue StandardError => e
        # TODO: fail from harvest_nsidc_json_into_solr should end up here?
        puts "harvest failed for #{target}: #{e.message}"
        puts e.backtrace
        exit ERRCODE_UNKNOWN
      end
    end
  end

  desc 'list_harvesters', 'List all harvesters'
  def list_harvesters
    puts harvester_map.keys
  end

  desc 'delete_all', 'Delete all documents from the index'
  option :environment, required: true
  def delete_all
    env = SearchSolrTools::SolrEnvironments[options[:environment]]
    `curl 'http://#{env[:host]}:#{env[:port]}/solr/update' -H 'Content-Type: text/xml; charset=utf-8' --data '<delete><query>*:*</query></delete>'`
    `curl 'http://#{env[:host]}:#{env[:port]}/solr/update' -H 'Content-Type: text/xml; charset=utf-8' --data '<commit/>'`
  end

  desc 'delete_all_auto_suggest', 'Delete all documents from the auto_suggest index'
  option :environment, required: true
  def delete_all_auto_suggest
    env = SearchSolrTools::SolrEnvironments[options[:environment]]
    `curl 'http://#{env[:host]}:#{env[:port]}/solr/update' -H 'Content-Type: text/xml; charset=utf-8' --data '<delete><query>*:*</query></delete>'`
    `curl 'http://#{env[:host]}:#{env[:port]}/solr/update' -H 'Content-Type: text/xml; charset=utf-8' --data '<commit/>'`
  end

  desc 'delete_by_data_center', 'Force deletion of documents for a specific data center with timestamps before the passed timestamp in format iso8601 (2014-07-14T21:49:21Z)'
  option :timestamp, required: true
  option :environment, required: true
  option :data_center, required: true
  def delete_by_data_center
    harvester = get_harvester_class(options[:data_center]).new options[:environment]
    harvester.delete_old_documents(options[:timestamp],
                                   "data_centers:\"#{SearchSolrTools::Helpers::SolrFormat::DATA_CENTER_NAMES[options[:data_center].upcase.to_sym][:long_name]}\"",
                                   SearchSolrTools::SolrEnvironments[harvester.environment][:collection_name],
                                   true)
  end

  no_tasks do
    def harvester_map
      {
        'bco_dmo' => SearchSolrTools::Harvesters::BcoDmo,
        'adc' => SearchSolrTools::Harvesters::Adc,
        'echo' => SearchSolrTools::Harvesters::Echo,
        'ices' => SearchSolrTools::Harvesters::Ices,
        'nmi' => SearchSolrTools::Harvesters::Nmi,
        'nodc' => SearchSolrTools::Harvesters::Nodc,
        'r2r' => SearchSolrTools::Harvesters::R2R,
        'rda' => SearchSolrTools::Harvesters::Rda,
        'usgs' => SearchSolrTools::Harvesters::Usgs,
        'tdar' => SearchSolrTools::Harvesters::Tdar,
        'pdc' => SearchSolrTools::Harvesters::Pdc,
        'nsidc' => SearchSolrTools::Harvesters::NsidcJson,
        'nsidc_auto_suggest' => SearchSolrTools::Harvesters::NsidcAutoSuggest,
        'ade_auto_suggest' => SearchSolrTools::Harvesters::AdeAutoSuggest
      }
    end

    def get_harvester_class(data_center_name)
      name = data_center_name.downcase.to_s
      raise("Invalid data center #{name}") unless harvester_map.key?(name)

      harvester_map[name]
    end
  end
end
SolrHarvestCLI.start(ARGV)
